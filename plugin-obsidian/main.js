/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
var __defProp = Object.defineProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/main.ts
__export(exports, {
  default: () => TaskSyncPlugin
});

// src/task-manager.ts
var App;
var TFile;
var Notice;
var normalizePath;
var MetadataCache;
var CachedMetadata;
try {
  const obsidian = require("obsidian");
  App = obsidian.App;
  TFile = obsidian.TFile;
  Notice = obsidian.Notice;
  normalizePath = obsidian.normalizePath;
  MetadataCache = obsidian.MetadataCache;
  CachedMetadata = obsidian.CachedMetadata;
} catch (error) {
  if (typeof global !== "undefined" && global.obsidian) {
    const obsidian = global.obsidian;
    App = obsidian.App;
    TFile = obsidian.TFile;
    Notice = obsidian.Notice;
    normalizePath = obsidian.normalizePath;
    MetadataCache = obsidian.MetadataCache;
    CachedMetadata = obsidian.CachedMetadata;
  } else {
    normalizePath = (path) => path.replace(/\\/g, "/").replace(/\/+/g, "/").replace(/\/$/, "");
  }
}
var TaskManager = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  isTasksPluginAvailable() {
    var _a, _b;
    return !!((_a = this.app.plugins) == null ? void 0 : _a.getPlugin("obsidian-tasks-plugin")) || !!((_b = this.app.plugins) == null ? void 0 : _b.getPlugin("tasks"));
  }
  getTasksFromMetadataCache() {
    const tasks = [];
    if (!this.app.metadataCache) {
      return tasks;
    }
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (!this.shouldProcessFile(file)) {
        continue;
      }
      const cache = this.app.metadataCache.getFileCache(file);
      if (!cache) {
        continue;
      }
      const fileTasks = this.extractTasksFromCache(file, cache);
      tasks.push(...fileTasks);
    }
    return tasks;
  }
  extractTasksFromCache(file, cache) {
    const tasks = [];
    if (!cache.listItems) {
      return tasks;
    }
    for (const listItem of cache.listItems) {
      if (this.isTaskListItem(listItem)) {
        const task = this.parseTaskFromCache(file, listItem);
        if (task) {
          tasks.push(task);
        }
      }
    }
    return tasks;
  }
  isTaskListItem(listItem) {
    return listItem.task !== void 0;
  }
  parseTaskFromCache(file, listItem) {
    var _a;
    const taskContent = listItem.text || "";
    const completed = listItem.task === "x" || listItem.task === "X";
    if (completed && !this.settings.includeCompletedTasks) {
      return null;
    }
    const metadata = this.parseExtendedTaskMetadata(taskContent);
    return {
      id: this.generateTaskId(file.path, listItem.position.start.line),
      description: metadata.cleanDescription,
      completed,
      filePath: file.path,
      lineNumber: listItem.position.start.line + 1,
      priority: metadata.priority,
      dueDate: metadata.dueDate,
      scheduledDate: metadata.scheduledDate,
      startDate: metadata.startDate,
      doneDate: metadata.doneDate,
      recurrence: metadata.recurrence,
      createdDate: metadata.createdDate,
      tags: metadata.tags,
      rawContent: taskContent,
      fileModifiedTime: (_a = file.stat) == null ? void 0 : _a.mtime
    };
  }
  parseExtendedTaskMetadata(content) {
    let cleanDescription = content;
    let priority;
    let dueDate;
    let scheduledDate;
    let startDate;
    let doneDate;
    let recurrence;
    let createdDate;
    const tags = [];
    const priorityMatch = content.match(/\s\((\w)\)\s/);
    if (priorityMatch) {
      priority = priorityMatch[1];
      cleanDescription = cleanDescription.replace(/\s\(\w\)\s/, " ");
    }
    const dueDateMatch = content.match(/📅\s*(\d{4}-\d{2}-\d{2})|due:(\d{4}-\d{2}-\d{2})/);
    if (dueDateMatch) {
      dueDate = dueDateMatch[1] || dueDateMatch[2];
      cleanDescription = cleanDescription.replace(/📅\s*\d{4}-\d{2}-\d{2}/, "").replace(/due:\d{4}-\d{2}-\d{2}/, "");
    }
    const scheduledMatch = content.match(/⏳\s*(\d{4}-\d{2}-\d{2})|scheduled:(\d{4}-\d{2}-\d{2})/);
    if (scheduledMatch) {
      scheduledDate = scheduledMatch[1] || scheduledMatch[2];
      cleanDescription = cleanDescription.replace(/⏳\s*\d{4}-\d{2}-\d{2}/, "").replace(/scheduled:\d{4}-\d{2}-\d{2}/, "");
    }
    const startMatch = content.match(/🛫\s*(\d{4}-\d{2}-\d{2})|start:(\d{4}-\d{2}-\d{2})/);
    if (startMatch) {
      startDate = startMatch[1] || startMatch[2];
      cleanDescription = cleanDescription.replace(/🛫\s*\d{4}-\d{2}-\d{2}/, "").replace(/start:\d{4}-\d{2}-\d{2}/, "");
    }
    const doneMatch = content.match(/✅\s*(\d{4}-\d{2}-\d{2})|done:(\d{4}-\d{2}-\d{2})/);
    if (doneMatch) {
      doneDate = doneMatch[1] || doneMatch[2];
      cleanDescription = cleanDescription.replace(/✅\s*\d{4}-\d{2}-\d{2}/, "").replace(/done:\d{4}-\d{2}-\d{2}/, "");
    }
    const recurMatch = content.match(/🔁\s*(.+?)(?=\s|$)|recur:(.+?)(?=\s|$)/);
    if (recurMatch) {
      recurrence = recurMatch[1] || recurMatch[2];
      cleanDescription = cleanDescription.replace(/🔁\s*.+?(?=\s|$)/, "").replace(/recur:.+?(?=\s|$)/, "");
    }
    const createdMatch = content.match(/➕\s*(\d{4}-\d{2}-\d{2})|created:(\d{4}-\d{2}-\d{2})/);
    if (createdMatch) {
      createdDate = createdMatch[1] || createdMatch[2];
      cleanDescription = cleanDescription.replace(/➕\s*\d{4}-\d{2}-\d{2}/, "").replace(/created:\d{4}-\d{2}-\d{2}/, "");
    }
    const tagRegex = /#([\w-]+)/g;
    let tagMatch;
    while ((tagMatch = tagRegex.exec(content)) !== null) {
      tags.push(tagMatch[1]);
    }
    cleanDescription = cleanDescription.replace(/\s+/g, " ").trim();
    return {
      cleanDescription,
      priority,
      dueDate,
      scheduledDate,
      startDate,
      doneDate,
      recurrence,
      createdDate,
      tags
    };
  }
  async collectTasks() {
    const cacheTasks = this.getTasksFromMetadataCache();
    if (cacheTasks.length > 0) {
      return cacheTasks;
    }
    const tasks = [];
    const markdownFiles = this.app.vault.getMarkdownFiles();
    for (const file of markdownFiles) {
      if (this.shouldProcessFile(file)) {
        const fileTasks = await this.extractTasksFromFile(file);
        tasks.push(...fileTasks);
      }
    }
    return tasks;
  }
  shouldProcessFile(file) {
    const filePath = normalizePath(file.path);
    for (const pattern of this.settings.taskFilePatterns) {
      if (this.matchesPattern(filePath, pattern)) {
        return true;
      }
    }
    return filePath.includes("/tasks/") || file.name.toLowerCase().includes("task");
  }
  matchesPattern(filePath, pattern) {
    if (pattern.includes("**")) {
      const regexPattern = pattern.replace(/\*\*/g, ".*").replace(/\*/g, "[^/]*").replace(/\?/g, "[^/]");
      const regex = new RegExp(`^${regexPattern}$`);
      return regex.test(filePath);
    }
    return filePath.includes(pattern.replace("*", ""));
  }
  async extractTasksFromFile(file) {
    const tasks = [];
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const task = this.parseTaskLine(line, file.path, i + 1);
      if (task) {
        tasks.push(task);
      }
    }
    return tasks;
  }
  parseTaskLine(line, filePath, lineNumber) {
    const taskRegex = /^\s*[-*]\s*\[(.)\]\s*(.+)$/;
    const match = line.match(taskRegex);
    if (!match) {
      return null;
    }
    const statusChar = match[1].toLowerCase();
    const description = match[2].trim();
    const completed = statusChar === "x";
    if (completed && !this.settings.includeCompletedTasks) {
      return null;
    }
    const metadata = this.parseExtendedTaskMetadata(description);
    return {
      id: this.generateTaskId(filePath, lineNumber),
      description: metadata.cleanDescription,
      completed,
      filePath,
      lineNumber,
      priority: metadata.priority,
      dueDate: metadata.dueDate,
      scheduledDate: metadata.scheduledDate,
      startDate: metadata.startDate,
      doneDate: metadata.doneDate,
      recurrence: metadata.recurrence,
      createdDate: metadata.createdDate,
      tags: metadata.tags,
      rawContent: line
    };
  }
  generateTaskId(filePath, lineNumber) {
    return `${filePath}:${lineNumber}`;
  }
  async updateTask(task, updates) {
    try {
      const file = this.app.vault.getAbstractFileByPath(task.filePath);
      if (!(file instanceof TFile)) {
        throw new Error(`File not found: ${task.filePath}`);
      }
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      if (task.lineNumber > lines.length) {
        throw new Error(`Line ${task.lineNumber} not found in file ${task.filePath}`);
      }
      const updatedLine = this.updateTaskLine(lines[task.lineNumber - 1], updates);
      lines[task.lineNumber - 1] = updatedLine;
      await this.app.vault.modify(file, lines.join("\n"));
    } catch (error) {
      console.error("Error updating task:", error);
      throw error;
    }
  }
  updateTaskLine(originalLine, updates) {
    let updatedLine = originalLine;
    if (updates.completed !== void 0) {
      const statusChar = updates.completed ? "x" : " ";
      updatedLine = updatedLine.replace(/\[(.)\]/, `[${statusChar}]`);
    }
    if (updates.description) {
      const taskMatch = updatedLine.match(/^\s*[-*]\s*\[(.)\]\s*/);
      if (taskMatch) {
        updatedLine = updatedLine.replace(/^\s*[-*]\s*\[(.)\]\s*.*$/, `${taskMatch[0]}${updates.description}`);
      }
    }
    return updatedLine;
  }
  async getModifiedTasks(since) {
    const allTasks = await this.collectTasks();
    return allTasks.filter((task) => {
      if (!task.fileModifiedTime) {
        return true;
      }
      return task.fileModifiedTime > since.getTime();
    });
  }
  async getTasksFromTasksPlugin() {
    const tasks = [];
    if (!this.isTasksPluginAvailable()) {
      return tasks;
    }
    try {
      const tasksPlugin = this.app.plugins.getPlugin("obsidian-tasks-plugin") || this.app.plugins.getPlugin("tasks");
      if (tasksPlugin && tasksPlugin.getTasks) {
        const pluginTasks = tasksPlugin.getTasks();
        for (const pluginTask of pluginTasks) {
          const task = this.convertTasksPluginTask(pluginTask);
          if (task) {
            tasks.push(task);
          }
        }
      }
    } catch (error) {
      console.warn("Error accessing Tasks plugin API:", error);
    }
    return tasks;
  }
  convertTasksPluginTask(pluginTask) {
    if (!pluginTask || !pluginTask.text) {
      return null;
    }
    const metadata = this.parseExtendedTaskMetadata(pluginTask.text);
    return {
      id: pluginTask.id || this.generateTaskId(pluginTask.path || "", pluginTask.line || 0),
      description: metadata.cleanDescription,
      completed: pluginTask.status === "x" || pluginTask.status === "X",
      filePath: pluginTask.path || "",
      lineNumber: pluginTask.line || 0,
      priority: metadata.priority,
      dueDate: metadata.dueDate,
      scheduledDate: metadata.scheduledDate,
      startDate: metadata.startDate,
      doneDate: metadata.doneDate,
      recurrence: metadata.recurrence,
      createdDate: metadata.createdDate,
      tags: metadata.tags,
      rawContent: pluginTask.text,
      status: pluginTask.status,
      blockId: pluginTask.blockId,
      fileModifiedTime: pluginTask.fileModifiedTime
    };
  }
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  autoSync: false,
  skedPalApiKey: "",
  skedPalWorkspaceId: "",
  taskFilePatterns: ["**/*.md"],
  syncInterval: 300,
  includeCompletedTasks: false
};

// src/settings-tab.ts
var App2;
var PluginSettingTab;
var Setting;
try {
  const obsidian = require("obsidian");
  App2 = obsidian.App;
  PluginSettingTab = obsidian.PluginSettingTab;
  Setting = obsidian.Setting;
} catch (error) {
  if (typeof global !== "undefined" && global.obsidian) {
    const obsidian = global.obsidian;
    App2 = obsidian.App;
    PluginSettingTab = obsidian.PluginSettingTab;
    Setting = obsidian.Setting;
  } else {
  }
}
var TaskSyncSettingTab = class extends PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Task Sync Settings" });
    new Setting(containerEl).setName("Auto-sync on task changes").setDesc("Automatically sync tasks when they are modified").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSync).onChange(async (value) => {
      this.plugin.settings.autoSync = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("SkedPal API Key").setDesc("Your SkedPal API key for authentication").addText((text) => text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.skedPalApiKey).onChange(async (value) => {
      this.plugin.settings.skedPalApiKey = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("SkedPal Workspace ID").setDesc("Your SkedPal workspace ID").addText((text) => text.setPlaceholder("Enter workspace ID").setValue(this.plugin.settings.skedPalWorkspaceId).onChange(async (value) => {
      this.plugin.settings.skedPalWorkspaceId = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("Sync interval (seconds)").setDesc("Interval for automatic sync in seconds (0 to disable)").addText((text) => text.setPlaceholder("300").setValue(this.plugin.settings.syncInterval.toString()).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue)) {
        this.plugin.settings.syncInterval = numValue;
        await this.plugin.saveSettings();
      }
    }));
    new Setting(containerEl).setName("Include completed tasks").setDesc("Sync tasks that are marked as completed").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeCompletedTasks).onChange(async (value) => {
      this.plugin.settings.includeCompletedTasks = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/chrome-bridge.ts
var ChromeExtensionBridge = class {
  constructor() {
    this.port = null;
    this.messageHandlers = new Map();
    this.pendingRequests = new Map();
    this.connectionStatus = { connected: false };
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.reconnectDelay = 1e3;
    this.setupMessageHandlers();
  }
  async connect() {
    try {
      if (!(chrome == null ? void 0 : chrome.runtime)) {
        throw new Error("Chrome runtime not available");
      }
      this.port = chrome.runtime.connectNative("com.obsidian.tasks.skedpal");
      this.port.onMessage.addListener((message) => {
        this.handleIncomingMessage(message);
      });
      this.port.onDisconnect.addListener(() => {
        this.handleDisconnect();
      });
      this.connectionStatus = {
        connected: true,
        lastConnected: new Date()
      };
      this.reconnectAttempts = 0;
      this.reconnectDelay = 1e3;
      console.log("Chrome extension bridge connected successfully");
      return true;
    } catch (error) {
      console.error("Failed to connect to Chrome extension:", error);
      this.connectionStatus = {
        connected: false,
        lastError: error.message
      };
      return false;
    }
  }
  disconnect() {
    if (this.port) {
      this.port.disconnect();
      this.port = null;
    }
    this.connectionStatus.connected = false;
    this.pendingRequests.clear();
  }
  async sendMessage(type, data) {
    if (!this.port || !this.connectionStatus.connected) {
      throw new Error("Not connected to Chrome extension");
    }
    const correlationId = this.generateCorrelationId();
    const message = {
      type,
      data,
      correlationId
    };
    return new Promise((resolve, reject) => {
      this.pendingRequests.set(correlationId, { resolve, reject });
      setTimeout(() => {
        if (this.pendingRequests.has(correlationId)) {
          this.pendingRequests.delete(correlationId);
          reject(new Error("Request timeout"));
        }
      }, 3e4);
      try {
        this.port.postMessage(message);
      } catch (error) {
        this.pendingRequests.delete(correlationId);
        reject(error);
      }
    });
  }
  registerHandler(type, handler) {
    this.messageHandlers.set(type, handler);
  }
  getConnectionStatus() {
    return { ...this.connectionStatus };
  }
  async reconnect() {
    this.disconnect();
    return await this.connect();
  }
  setupMessageHandlers() {
    this.registerHandler("ping", async () => ({ pong: true }));
    this.registerHandler("status", async () => this.getConnectionStatus());
  }
  handleIncomingMessage(message) {
    var _a;
    if (message.correlationId && this.pendingRequests.has(message.correlationId)) {
      const { resolve, reject } = this.pendingRequests.get(message.correlationId);
      this.pendingRequests.delete(message.correlationId);
      if (message.type === "error") {
        reject(new Error(((_a = message.data) == null ? void 0 : _a.error) || "Unknown error"));
      } else {
        resolve(message.data);
      }
      return;
    }
    const handler = this.messageHandlers.get(message.type);
    if (handler) {
      handler(message.data).then((result) => {
        if (message.correlationId) {
          this.sendResponse(message.correlationId, { success: true, data: result });
        }
      }).catch((error) => {
        if (message.correlationId) {
          this.sendResponse(message.correlationId, { success: false, error: error.message });
        }
      });
    }
  }
  handleDisconnect() {
    this.port = null;
    this.connectionStatus.connected = false;
    this.connectionStatus.lastError = "Disconnected from Chrome extension";
    for (const [correlationId, { reject }] of this.pendingRequests) {
      reject(new Error("Connection lost"));
    }
    this.pendingRequests.clear();
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      setTimeout(() => {
        this.reconnectAttempts++;
        this.reconnectDelay *= 2;
        this.connect();
      }, this.reconnectDelay);
    }
  }
  sendResponse(correlationId, response) {
    if (this.port && this.connectionStatus.connected) {
      const message = {
        type: "response",
        data: response,
        correlationId
      };
      this.port.postMessage(message);
    }
  }
  generateCorrelationId() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
};

// src/main.ts
var Plugin;
var App3;
var TFile2;
var Notice2;
try {
  const obsidian = require("obsidian");
  Plugin = obsidian.Plugin;
  App3 = obsidian.App;
  TFile2 = obsidian.TFile;
  Notice2 = obsidian.Notice;
} catch (error) {
  if (typeof global !== "undefined" && global.obsidian) {
    const obsidian = global.obsidian;
    Plugin = obsidian.Plugin;
    App3 = obsidian.App;
    TFile2 = obsidian.TFile;
    Notice2 = obsidian.Notice;
  } else {
  }
}
var TaskSyncPlugin = class extends Plugin {
  async onload() {
    console.log("Loading Obsidian Tasks - SkedPal Sync plugin");
    await this.loadSettings();
    this.taskManager = new TaskManager(this.app, this.settings);
    this.chromeBridge = new ChromeExtensionBridge();
    this.initializeChromeBridge();
    this.addSettingTab(new TaskSyncSettingTab(this.app, this));
    this.addCommand({
      id: "sync-tasks-to-skedpal",
      name: "Sync tasks to SkedPal",
      callback: () => {
        this.syncTasks();
      }
    });
    this.addCommand({
      id: "sync-tasks-from-skedpal",
      name: "Sync tasks from SkedPal",
      callback: () => {
        this.syncFromSkedPal();
      }
    });
    this.addCommand({
      id: "check-chrome-connection",
      name: "Check Chrome Extension Connection",
      callback: () => {
        this.checkChromeConnection();
      }
    });
    this.addCommand({
      id: "reconnect-chrome-extension",
      name: "Reconnect to Chrome Extension",
      callback: () => {
        this.reconnectChromeExtension();
      }
    });
    this.registerEvent(this.app.vault.on("modify", (file) => {
      if (this.isTaskFile(file)) {
        this.handleTaskChange(file);
      }
    }));
    new Notice2("Obsidian Tasks - SkedPal Sync plugin loaded successfully");
  }
  onunload() {
    console.log("Unloading Obsidian Tasks - SkedPal Sync plugin");
    if (this.chromeBridge) {
      this.chromeBridge.disconnect();
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  isTaskFile(file) {
    var _a;
    if (file.extension !== "md") {
      return false;
    }
    if (file.path.includes("/tasks/") || file.name.toLowerCase().includes("task")) {
      return true;
    }
    try {
      const cache = (_a = this.app.metadataCache) == null ? void 0 : _a.getFileCache(file);
      if (cache == null ? void 0 : cache.listItems) {
        return cache.listItems.some((item) => item.task !== void 0);
      }
    } catch (error) {
    }
    return false;
  }
  async handleTaskChange(file) {
    if (this.settings.autoSync) {
      await this.syncTasks();
    }
  }
  async syncTasks() {
    try {
      const tasks = await this.taskManager.collectTasks();
      new Notice2(`Found ${tasks.length} tasks to sync`);
    } catch (error) {
      console.error("Error syncing tasks:", error);
      new Notice2("Error syncing tasks: " + error.message);
    }
  }
  async syncFromSkedPal() {
    try {
      new Notice2("Syncing tasks from SkedPal...");
    } catch (error) {
      console.error("Error syncing from SkedPal:", error);
      new Notice2("Error syncing from SkedPal: " + error.message);
    }
  }
  async initializeChromeBridge() {
    try {
      const connected = await this.chromeBridge.connect();
      if (connected) {
        console.log("Chrome extension bridge initialized successfully");
        this.chromeBridge.registerHandler("sync-tasks", async (data) => {
          return await this.handleTaskSync(data);
        });
        this.chromeBridge.registerHandler("get-tasks", async () => {
          return await this.taskManager.collectTasks();
        });
      } else {
        console.warn("Chrome extension bridge initialization failed");
      }
    } catch (error) {
      console.error("Error initializing Chrome extension bridge:", error);
    }
  }
  async checkChromeConnection() {
    const status = this.chromeBridge.getConnectionStatus();
    if (status.connected) {
      new Notice2("Chrome extension is connected");
    } else {
      new Notice2(`Chrome extension is not connected: ${status.lastError || "Unknown error"}`);
    }
  }
  async reconnectChromeExtension() {
    try {
      new Notice2("Attempting to reconnect to Chrome extension...");
      const connected = await this.chromeBridge.reconnect();
      if (connected) {
        new Notice2("Successfully reconnected to Chrome extension");
      } else {
        new Notice2("Failed to reconnect to Chrome extension");
      }
    } catch (error) {
      console.error("Error reconnecting to Chrome extension:", error);
      new Notice2("Error reconnecting to Chrome extension: " + error.message);
    }
  }
  async handleTaskSync(data) {
    try {
      const tasks = await this.taskManager.collectTasks();
      return {
        success: true,
        tasks,
        count: tasks.length
      };
    } catch (error) {
      console.error("Error handling task sync:", error);
      return {
        success: false,
        error: error.message
      };
    }
  }
};
