/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
var __defProp = Object.defineProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/main.ts
__export(exports, {
  default: () => TaskSyncPlugin
});

// src/task-manager.ts
var App;
var TFile;
var Notice;
var normalizePath;
try {
  const obsidian = require("obsidian");
  App = obsidian.App;
  TFile = obsidian.TFile;
  Notice = obsidian.Notice;
  normalizePath = obsidian.normalizePath;
} catch (error) {
  if (typeof global !== "undefined" && global.obsidian) {
    const obsidian = global.obsidian;
    App = obsidian.App;
    TFile = obsidian.TFile;
    Notice = obsidian.Notice;
    normalizePath = obsidian.normalizePath;
  } else {
    normalizePath = (path) => path.replace(/\\/g, "/").replace(/\/+/g, "/").replace(/\/$/, "");
  }
}
var TaskManager = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  async collectTasks() {
    const tasks = [];
    const markdownFiles = this.app.vault.getMarkdownFiles();
    for (const file of markdownFiles) {
      if (this.shouldProcessFile(file)) {
        const fileTasks = await this.extractTasksFromFile(file);
        tasks.push(...fileTasks);
      }
    }
    return tasks;
  }
  shouldProcessFile(file) {
    const filePath = normalizePath(file.path);
    for (const pattern of this.settings.taskFilePatterns) {
      if (this.matchesPattern(filePath, pattern)) {
        return true;
      }
    }
    return filePath.includes("/tasks/") || file.name.toLowerCase().includes("task");
  }
  matchesPattern(filePath, pattern) {
    if (pattern.includes("**")) {
      const regexPattern = pattern.replace(/\*\*/g, ".*").replace(/\*/g, "[^/]*").replace(/\?/g, "[^/]");
      const regex = new RegExp(`^${regexPattern}$`);
      return regex.test(filePath);
    }
    return filePath.includes(pattern.replace("*", ""));
  }
  async extractTasksFromFile(file) {
    const tasks = [];
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const task = this.parseTaskLine(line, file.path, i + 1);
      if (task) {
        tasks.push(task);
      }
    }
    return tasks;
  }
  parseTaskLine(line, filePath, lineNumber) {
    const taskRegex = /^\s*[-*]\s*\[(.)\]\s*(.+)$/;
    const match = line.match(taskRegex);
    if (!match) {
      return null;
    }
    const statusChar = match[1].toLowerCase();
    const description = match[2].trim();
    const completed = statusChar === "x";
    if (completed && !this.settings.includeCompletedTasks) {
      return null;
    }
    const priority = this.extractPriority(description);
    const dueDate = this.extractDueDate(description);
    const tags = this.extractTags(description);
    return {
      id: this.generateTaskId(filePath, lineNumber),
      description: this.cleanDescription(description),
      completed,
      filePath,
      lineNumber,
      priority,
      dueDate,
      tags,
      rawContent: line
    };
  }
  extractPriority(description) {
    const priorityRegex = /\s\((.)\)\s/;
    const match = description.match(priorityRegex);
    return match ? match[1] : void 0;
  }
  extractDueDate(description) {
    const dateRegex = /📅\s*(\d{4}-\d{2}-\d{2})|⏳\s*(\d{4}-\d{2}-\d{2})/;
    const match = description.match(dateRegex);
    return match ? match[1] || match[2] : void 0;
  }
  extractTags(description) {
    const tagRegex = /#([\w-]+)/g;
    const tags = [];
    let match;
    while ((match = tagRegex.exec(description)) !== null) {
      tags.push(match[1]);
    }
    return tags;
  }
  cleanDescription(description) {
    let cleaned = description.replace(/\s\(.\)\s/, " ");
    cleaned = cleaned.replace(/📅\s*\d{4}-\d{2}-\d{2}/, "");
    cleaned = cleaned.replace(/⏳\s*\d{4}-\d{2}-\d{2}/, "");
    return cleaned.trim();
  }
  generateTaskId(filePath, lineNumber) {
    return `${filePath}:${lineNumber}`;
  }
  async updateTask(task, updates) {
    try {
      const file = this.app.vault.getAbstractFileByPath(task.filePath);
      if (!(file instanceof TFile)) {
        throw new Error(`File not found: ${task.filePath}`);
      }
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      if (task.lineNumber > lines.length) {
        throw new Error(`Line ${task.lineNumber} not found in file ${task.filePath}`);
      }
      const updatedLine = this.updateTaskLine(lines[task.lineNumber - 1], updates);
      lines[task.lineNumber - 1] = updatedLine;
      await this.app.vault.modify(file, lines.join("\n"));
    } catch (error) {
      console.error("Error updating task:", error);
      throw error;
    }
  }
  updateTaskLine(originalLine, updates) {
    let updatedLine = originalLine;
    if (updates.completed !== void 0) {
      const statusChar = updates.completed ? "x" : " ";
      updatedLine = updatedLine.replace(/\[(.)\]/, `[${statusChar}]`);
    }
    if (updates.description) {
      const taskMatch = updatedLine.match(/^\s*[-*]\s*\[(.)\]\s*/);
      if (taskMatch) {
        updatedLine = updatedLine.replace(/^\s*[-*]\s*\[(.)\]\s*.*$/, `${taskMatch[0]}${updates.description}`);
      }
    }
    return updatedLine;
  }
  async getModifiedTasks(since) {
    const allTasks = await this.collectTasks();
    return allTasks;
  }
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  autoSync: false,
  skedPalApiKey: "",
  skedPalWorkspaceId: "",
  taskFilePatterns: ["**/*.md"],
  syncInterval: 300,
  includeCompletedTasks: false
};

// src/settings-tab.ts
var App2;
var PluginSettingTab;
var Setting;
try {
  const obsidian = require("obsidian");
  App2 = obsidian.App;
  PluginSettingTab = obsidian.PluginSettingTab;
  Setting = obsidian.Setting;
} catch (error) {
  if (typeof global !== "undefined" && global.obsidian) {
    const obsidian = global.obsidian;
    App2 = obsidian.App;
    PluginSettingTab = obsidian.PluginSettingTab;
    Setting = obsidian.Setting;
  } else {
  }
}
var TaskSyncSettingTab = class extends PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Task Sync Settings" });
    new Setting(containerEl).setName("Auto-sync on task changes").setDesc("Automatically sync tasks when they are modified").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSync).onChange(async (value) => {
      this.plugin.settings.autoSync = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("SkedPal API Key").setDesc("Your SkedPal API key for authentication").addText((text) => text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.skedPalApiKey).onChange(async (value) => {
      this.plugin.settings.skedPalApiKey = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("SkedPal Workspace ID").setDesc("Your SkedPal workspace ID").addText((text) => text.setPlaceholder("Enter workspace ID").setValue(this.plugin.settings.skedPalWorkspaceId).onChange(async (value) => {
      this.plugin.settings.skedPalWorkspaceId = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("Sync interval (seconds)").setDesc("Interval for automatic sync in seconds (0 to disable)").addText((text) => text.setPlaceholder("300").setValue(this.plugin.settings.syncInterval.toString()).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue)) {
        this.plugin.settings.syncInterval = numValue;
        await this.plugin.saveSettings();
      }
    }));
    new Setting(containerEl).setName("Include completed tasks").setDesc("Sync tasks that are marked as completed").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeCompletedTasks).onChange(async (value) => {
      this.plugin.settings.includeCompletedTasks = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/main.ts
var Plugin;
var App3;
var TFile2;
var Notice2;
try {
  const obsidian = require("obsidian");
  Plugin = obsidian.Plugin;
  App3 = obsidian.App;
  TFile2 = obsidian.TFile;
  Notice2 = obsidian.Notice;
} catch (error) {
  if (typeof global !== "undefined" && global.obsidian) {
    const obsidian = global.obsidian;
    Plugin = obsidian.Plugin;
    App3 = obsidian.App;
    TFile2 = obsidian.TFile;
    Notice2 = obsidian.Notice;
  } else {
  }
}
var TaskSyncPlugin = class extends Plugin {
  async onload() {
    console.log("Loading Obsidian Tasks - SkedPal Sync plugin");
    await this.loadSettings();
    this.taskManager = new TaskManager(this.app, this.settings);
    this.addSettingTab(new TaskSyncSettingTab(this.app, this));
    this.addCommand({
      id: "sync-tasks-to-skedpal",
      name: "Sync tasks to SkedPal",
      callback: () => {
        this.syncTasks();
      }
    });
    this.addCommand({
      id: "sync-tasks-from-skedpal",
      name: "Sync tasks from SkedPal",
      callback: () => {
        this.syncFromSkedPal();
      }
    });
    this.registerEvent(this.app.vault.on("modify", (file) => {
      if (this.isTaskFile(file)) {
        this.handleTaskChange(file);
      }
    }));
    new Notice2("Obsidian Tasks - SkedPal Sync plugin loaded successfully");
  }
  onunload() {
    console.log("Unloading Obsidian Tasks - SkedPal Sync plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  isTaskFile(file) {
    return file.extension === "md" && (file.path.includes("/tasks/") || file.name.toLowerCase().includes("task"));
  }
  async handleTaskChange(file) {
    if (this.settings.autoSync) {
      await this.syncTasks();
    }
  }
  async syncTasks() {
    try {
      const tasks = await this.taskManager.collectTasks();
      new Notice2(`Found ${tasks.length} tasks to sync`);
    } catch (error) {
      console.error("Error syncing tasks:", error);
      new Notice2("Error syncing tasks: " + error.message);
    }
  }
  async syncFromSkedPal() {
    try {
      new Notice2("Syncing tasks from SkedPal...");
    } catch (error) {
      console.error("Error syncing from SkedPal:", error);
      new Notice2("Error syncing from SkedPal: " + error.message);
    }
  }
};
