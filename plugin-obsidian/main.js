/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
var __defProp = Object.defineProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/main.ts
__export(exports, {
  default: () => TaskSyncPlugin
});

// src/task-manager.ts
var App;
var TFile;
var Notice;
var normalizePath;
var MetadataCache;
var CachedMetadata;
try {
  const obsidian = require("obsidian");
  App = obsidian.App;
  TFile = obsidian.TFile;
  Notice = obsidian.Notice;
  normalizePath = obsidian.normalizePath;
  MetadataCache = obsidian.MetadataCache;
  CachedMetadata = obsidian.CachedMetadata;
} catch (error) {
  if (typeof global !== "undefined" && global.obsidian) {
    const obsidian = global.obsidian;
    App = obsidian.App;
    TFile = obsidian.TFile;
    Notice = obsidian.Notice;
    normalizePath = obsidian.normalizePath;
    MetadataCache = obsidian.MetadataCache;
    CachedMetadata = obsidian.CachedMetadata;
  } else {
    normalizePath = (path) => path.replace(/\\/g, "/").replace(/\/+/g, "/").replace(/\/$/, "");
  }
}
var TaskManager = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  isTasksPluginAvailable() {
    var _a, _b;
    return !!((_a = this.app.plugins) == null ? void 0 : _a.getPlugin("obsidian-tasks-plugin")) || !!((_b = this.app.plugins) == null ? void 0 : _b.getPlugin("tasks"));
  }
  getTasksFromMetadataCache() {
    const tasks = [];
    if (!this.app.metadataCache) {
      return tasks;
    }
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (!this.shouldProcessFile(file)) {
        continue;
      }
      const cache = this.app.metadataCache.getFileCache(file);
      if (!cache) {
        continue;
      }
      const fileTasks = this.extractTasksFromCache(file, cache);
      tasks.push(...fileTasks);
    }
    return tasks;
  }
  extractTasksFromCache(file, cache) {
    const tasks = [];
    if (!cache.listItems) {
      return tasks;
    }
    for (const listItem of cache.listItems) {
      if (this.isTaskListItem(listItem)) {
        const task = this.parseTaskFromCache(file, listItem);
        if (task) {
          tasks.push(task);
        }
      }
    }
    return tasks;
  }
  isTaskListItem(listItem) {
    return listItem.task !== void 0;
  }
  parseTaskFromCache(file, listItem) {
    var _a;
    const taskContent = listItem.text || "";
    const completed = listItem.task === "x" || listItem.task === "X";
    if (completed && !this.settings.includeCompletedTasks) {
      return null;
    }
    const metadata = this.parseExtendedTaskMetadata(taskContent);
    return {
      id: this.generateTaskId(file.path, listItem.position.start.line),
      description: metadata.cleanDescription,
      completed,
      filePath: file.path,
      lineNumber: listItem.position.start.line + 1,
      priority: metadata.priority,
      dueDate: metadata.dueDate,
      scheduledDate: metadata.scheduledDate,
      startDate: metadata.startDate,
      doneDate: metadata.doneDate,
      recurrence: metadata.recurrence,
      createdDate: metadata.createdDate,
      tags: metadata.tags,
      rawContent: taskContent,
      fileModifiedTime: (_a = file.stat) == null ? void 0 : _a.mtime
    };
  }
  parseExtendedTaskMetadata(content) {
    let cleanDescription = content;
    let priority;
    let dueDate;
    let scheduledDate;
    let startDate;
    let doneDate;
    let recurrence;
    let createdDate;
    const tags = [];
    const priorityMatch = content.match(/\s\((\w)\)\s/);
    if (priorityMatch) {
      priority = priorityMatch[1];
      cleanDescription = cleanDescription.replace(/\s\(\w\)\s/, " ");
    }
    const dueDateMatch = content.match(/ðŸ“…\s*(\d{4}-\d{2}-\d{2})|due:(\d{4}-\d{2}-\d{2})/);
    if (dueDateMatch) {
      dueDate = dueDateMatch[1] || dueDateMatch[2];
      cleanDescription = cleanDescription.replace(/ðŸ“…\s*\d{4}-\d{2}-\d{2}/, "").replace(/due:\d{4}-\d{2}-\d{2}/, "");
    }
    const scheduledMatch = content.match(/â³\s*(\d{4}-\d{2}-\d{2})|scheduled:(\d{4}-\d{2}-\d{2})/);
    if (scheduledMatch) {
      scheduledDate = scheduledMatch[1] || scheduledMatch[2];
      cleanDescription = cleanDescription.replace(/â³\s*\d{4}-\d{2}-\d{2}/, "").replace(/scheduled:\d{4}-\d{2}-\d{2}/, "");
    }
    const startMatch = content.match(/ðŸ›«\s*(\d{4}-\d{2}-\d{2})|start:(\d{4}-\d{2}-\d{2})/);
    if (startMatch) {
      startDate = startMatch[1] || startMatch[2];
      cleanDescription = cleanDescription.replace(/ðŸ›«\s*\d{4}-\d{2}-\d{2}/, "").replace(/start:\d{4}-\d{2}-\d{2}/, "");
    }
    const doneMatch = content.match(/âœ…\s*(\d{4}-\d{2}-\d{2})|done:(\d{4}-\d{2}-\d{2})/);
    if (doneMatch) {
      doneDate = doneMatch[1] || doneMatch[2];
      cleanDescription = cleanDescription.replace(/âœ…\s*\d{4}-\d{2}-\d{2}/, "").replace(/done:\d{4}-\d{2}-\d{2}/, "");
    }
    const recurMatch = content.match(/ðŸ”\s*(.+?)(?=\s|$)|recur:(.+?)(?=\s|$)/);
    if (recurMatch) {
      recurrence = recurMatch[1] || recurMatch[2];
      cleanDescription = cleanDescription.replace(/ðŸ”\s*.+?(?=\s|$)/, "").replace(/recur:.+?(?=\s|$)/, "");
    }
    const createdMatch = content.match(/âž•\s*(\d{4}-\d{2}-\d{2})|created:(\d{4}-\d{2}-\d{2})/);
    if (createdMatch) {
      createdDate = createdMatch[1] || createdMatch[2];
      cleanDescription = cleanDescription.replace(/âž•\s*\d{4}-\d{2}-\d{2}/, "").replace(/created:\d{4}-\d{2}-\d{2}/, "");
    }
    const tagRegex = /#([\w-]+)/g;
    let tagMatch;
    while ((tagMatch = tagRegex.exec(content)) !== null) {
      tags.push(tagMatch[1]);
    }
    cleanDescription = cleanDescription.replace(/\s+/g, " ").trim();
    return {
      cleanDescription,
      priority,
      dueDate,
      scheduledDate,
      startDate,
      doneDate,
      recurrence,
      createdDate,
      tags
    };
  }
  async collectTasks() {
    const cacheTasks = this.getTasksFromMetadataCache();
    if (cacheTasks.length > 0) {
      return cacheTasks;
    }
    const tasks = [];
    const markdownFiles = this.app.vault.getMarkdownFiles();
    for (const file of markdownFiles) {
      if (this.shouldProcessFile(file)) {
        const fileTasks = await this.extractTasksFromFile(file);
        tasks.push(...fileTasks);
      }
    }
    return tasks;
  }
  shouldProcessFile(file) {
    const filePath = normalizePath(file.path);
    for (const pattern of this.settings.taskFilePatterns) {
      if (this.matchesPattern(filePath, pattern)) {
        return true;
      }
    }
    return filePath.includes("/tasks/") || file.name.toLowerCase().includes("task");
  }
  matchesPattern(filePath, pattern) {
    if (pattern.includes("**")) {
      const regexPattern = pattern.replace(/\*\*/g, ".*").replace(/\*/g, "[^/]*").replace(/\?/g, "[^/]");
      const regex = new RegExp(`^${regexPattern}$`);
      return regex.test(filePath);
    }
    return filePath.includes(pattern.replace("*", ""));
  }
  async extractTasksFromFile(file) {
    const tasks = [];
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const task = this.parseTaskLine(line, file.path, i + 1);
      if (task) {
        tasks.push(task);
      }
    }
    return tasks;
  }
  parseTaskLine(line, filePath, lineNumber) {
    const taskRegex = /^\s*[-*]\s*\[(.)\]\s*(.+)$/;
    const match = line.match(taskRegex);
    if (!match) {
      return null;
    }
    const statusChar = match[1].toLowerCase();
    const description = match[2].trim();
    const completed = statusChar === "x";
    if (completed && !this.settings.includeCompletedTasks) {
      return null;
    }
    const metadata = this.parseExtendedTaskMetadata(description);
    return {
      id: this.generateTaskId(filePath, lineNumber),
      description: metadata.cleanDescription,
      completed,
      filePath,
      lineNumber,
      priority: metadata.priority,
      dueDate: metadata.dueDate,
      scheduledDate: metadata.scheduledDate,
      startDate: metadata.startDate,
      doneDate: metadata.doneDate,
      recurrence: metadata.recurrence,
      createdDate: metadata.createdDate,
      tags: metadata.tags,
      rawContent: line
    };
  }
  generateTaskId(filePath, lineNumber) {
    return `${filePath}:${lineNumber}`;
  }
  async updateTask(task, updates) {
    try {
      const file = this.app.vault.getAbstractFileByPath(task.filePath);
      if (!(file instanceof TFile)) {
        throw new Error(`File not found: ${task.filePath}`);
      }
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      if (task.lineNumber > lines.length) {
        throw new Error(`Line ${task.lineNumber} not found in file ${task.filePath}`);
      }
      const updatedLine = this.updateTaskLine(lines[task.lineNumber - 1], updates);
      lines[task.lineNumber - 1] = updatedLine;
      await this.app.vault.modify(file, lines.join("\n"));
    } catch (error) {
      console.error("Error updating task:", error);
      throw error;
    }
  }
  updateTaskLine(originalLine, updates) {
    let updatedLine = originalLine;
    if (updates.completed !== void 0) {
      const statusChar = updates.completed ? "x" : " ";
      updatedLine = updatedLine.replace(/\[(.)\]/, `[${statusChar}]`);
    }
    if (updates.description) {
      const taskMatch = updatedLine.match(/^\s*[-*]\s*\[(.)\]\s*/);
      if (taskMatch) {
        updatedLine = updatedLine.replace(/^\s*[-*]\s*\[(.)\]\s*.*$/, `${taskMatch[0]}${updates.description}`);
      }
    }
    return updatedLine;
  }
  async getModifiedTasks(since) {
    const allTasks = await this.collectTasks();
    return allTasks.filter((task) => {
      if (!task.fileModifiedTime) {
        return true;
      }
      return task.fileModifiedTime > since.getTime();
    });
  }
  async getTasksFromTasksPlugin() {
    const tasks = [];
    if (!this.isTasksPluginAvailable()) {
      return tasks;
    }
    try {
      const tasksPlugin = this.app.plugins.getPlugin("obsidian-tasks-plugin") || this.app.plugins.getPlugin("tasks");
      if (tasksPlugin && tasksPlugin.getTasks) {
        const pluginTasks = tasksPlugin.getTasks();
        for (const pluginTask of pluginTasks) {
          const task = this.convertTasksPluginTask(pluginTask);
          if (task) {
            tasks.push(task);
          }
        }
      }
    } catch (error) {
      console.warn("Error accessing Tasks plugin API:", error);
    }
    return tasks;
  }
  convertTasksPluginTask(pluginTask) {
    if (!pluginTask || !pluginTask.text) {
      return null;
    }
    const metadata = this.parseExtendedTaskMetadata(pluginTask.text);
    return {
      id: pluginTask.id || this.generateTaskId(pluginTask.path || "", pluginTask.line || 0),
      description: metadata.cleanDescription,
      completed: pluginTask.status === "x" || pluginTask.status === "X",
      filePath: pluginTask.path || "",
      lineNumber: pluginTask.line || 0,
      priority: metadata.priority,
      dueDate: metadata.dueDate,
      scheduledDate: metadata.scheduledDate,
      startDate: metadata.startDate,
      doneDate: metadata.doneDate,
      recurrence: metadata.recurrence,
      createdDate: metadata.createdDate,
      tags: metadata.tags,
      rawContent: pluginTask.text,
      status: pluginTask.status,
      blockId: pluginTask.blockId,
      fileModifiedTime: pluginTask.fileModifiedTime
    };
  }
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  autoSync: false,
  skedPalApiKey: "",
  skedPalWorkspaceId: "",
  taskFilePatterns: ["**/*.md"],
  syncInterval: 300,
  includeCompletedTasks: false,
  conflictResolutionStrategy: "most_recent",
  maxRetryAttempts: 3,
  syncDirection: "bidirectional",
  enableStatusTracking: true
};

// src/settings-tab.ts
var App2;
var PluginSettingTab;
var Setting;
try {
  const obsidian = require("obsidian");
  App2 = obsidian.App;
  PluginSettingTab = obsidian.PluginSettingTab;
  Setting = obsidian.Setting;
} catch (error) {
  if (typeof global !== "undefined" && global.obsidian) {
    const obsidian = global.obsidian;
    App2 = obsidian.App;
    PluginSettingTab = obsidian.PluginSettingTab;
    Setting = obsidian.Setting;
  } else {
  }
}
var TaskSyncSettingTab = class extends PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Task Sync Settings" });
    new Setting(containerEl).setName("Auto-sync on task changes").setDesc("Automatically sync tasks when they are modified").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSync).onChange(async (value) => {
      this.plugin.settings.autoSync = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("SkedPal API Key").setDesc("Your SkedPal API key for authentication").addText((text) => text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.skedPalApiKey).onChange(async (value) => {
      this.plugin.settings.skedPalApiKey = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("SkedPal Workspace ID").setDesc("Your SkedPal workspace ID").addText((text) => text.setPlaceholder("Enter workspace ID").setValue(this.plugin.settings.skedPalWorkspaceId).onChange(async (value) => {
      this.plugin.settings.skedPalWorkspaceId = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("Sync interval (seconds)").setDesc("Interval for automatic sync in seconds (0 to disable)").addText((text) => text.setPlaceholder("300").setValue(this.plugin.settings.syncInterval.toString()).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue)) {
        this.plugin.settings.syncInterval = numValue;
        await this.plugin.saveSettings();
      }
    }));
    new Setting(containerEl).setName("Include completed tasks").setDesc("Sync tasks that are marked as completed").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeCompletedTasks).onChange(async (value) => {
      this.plugin.settings.includeCompletedTasks = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/sync-engine.ts
var ConflictResolutionStrategy;
(function(ConflictResolutionStrategy2) {
  ConflictResolutionStrategy2["OBSIDIAN_WINS"] = "obsidian_wins";
  ConflictResolutionStrategy2["SKEDPAL_WINS"] = "skedpal_wins";
  ConflictResolutionStrategy2["MANUAL_RESOLUTION"] = "manual_resolution";
  ConflictResolutionStrategy2["MOST_RECENT"] = "most_recent";
})(ConflictResolutionStrategy || (ConflictResolutionStrategy = {}));
var SynchronizationEngine = class {
  constructor(settings) {
    this.changeQueue = [];
    this.retryCount = 0;
    this.maxRetries = 3;
    this.settings = settings;
    this.syncStatus = {
      lastSyncTime: new Date(0),
      syncInProgress: false,
      tasksSynced: 0,
      conflictsResolved: 0,
      syncDirection: "bidirectional"
    };
  }
  async synchronizeTasks(obsidianTasks, skedpalTasks) {
    if (this.syncStatus.syncInProgress) {
      throw new Error("Synchronization already in progress");
    }
    this.syncStatus.syncInProgress = true;
    this.syncStatus.lastError = void 0;
    try {
      const obsidianChanges = await this.detectChanges(obsidianTasks, "obsidian");
      const skedpalChanges = await this.detectChanges(skedpalTasks, "skedpal");
      const mergedChanges = await this.mergeChanges(obsidianChanges, skedpalChanges);
      await this.applyChanges(mergedChanges);
      this.syncStatus.lastSyncTime = new Date();
      this.syncStatus.tasksSynced = mergedChanges.length;
    } catch (error) {
      this.syncStatus.lastError = error.message;
      await this.handleSyncError(error);
    } finally {
      this.syncStatus.syncInProgress = false;
    }
    return this.syncStatus;
  }
  async detectChanges(tasks, source) {
    const changes = [];
    const lastSyncTime = this.syncStatus.lastSyncTime;
    for (const task of tasks) {
      const taskModifiedTime = this.getTaskModifiedTime(task, source);
      if (taskModifiedTime > lastSyncTime) {
        changes.push({
          taskId: this.getTaskId(task, source),
          timestamp: taskModifiedTime,
          changes: this.extractChanges(task, source),
          source
        });
      }
    }
    return changes;
  }
  getTaskModifiedTime(task, source) {
    if (source === "obsidian") {
      return new Date(task.fileModifiedTime || Date.now());
    } else {
      return new Date(task.lastModified || task.createdAt || Date.now());
    }
  }
  getTaskId(task, source) {
    if (source === "obsidian") {
      return task.id;
    } else {
      return task.id || task.externalId;
    }
  }
  extractChanges(task, source) {
    if (source === "obsidian") {
      const obsidianTask = task;
      return {
        description: obsidianTask.description,
        completed: obsidianTask.completed,
        priority: obsidianTask.priority,
        dueDate: obsidianTask.dueDate,
        scheduledDate: obsidianTask.scheduledDate,
        startDate: obsidianTask.startDate,
        tags: obsidianTask.tags
      };
    } else {
      return {
        description: task.title || task.name,
        completed: task.status === "completed" || task.done,
        priority: this.mapSkedPalPriority(task.priority),
        dueDate: task.dueDate,
        scheduledDate: task.scheduledDate,
        startDate: task.startDate,
        tags: task.tags || task.categories || []
      };
    }
  }
  mapSkedPalPriority(skedpalPriority) {
    const priorityMap = {
      "high": "A",
      "medium": "B",
      "low": "C",
      "none": "D"
    };
    return priorityMap[skedpalPriority == null ? void 0 : skedpalPriority.toLowerCase()];
  }
  async mergeChanges(obsidianChanges, skedpalChanges) {
    const mergedChanges = [];
    const conflictMap = new Map();
    for (const change of [...obsidianChanges, ...skedpalChanges]) {
      if (!conflictMap.has(change.taskId)) {
        conflictMap.set(change.taskId, []);
      }
      conflictMap.get(change.taskId).push(change);
    }
    for (const [taskId, changes] of conflictMap) {
      if (changes.length === 1) {
        mergedChanges.push(changes[0]);
      } else {
        const resolvedChange = await this.resolveConflict(changes);
        if (resolvedChange) {
          mergedChanges.push(resolvedChange);
          this.syncStatus.conflictsResolved++;
        }
      }
    }
    return mergedChanges;
  }
  async resolveConflict(changes) {
    const strategy = this.settings.conflictResolutionStrategy || ConflictResolutionStrategy.MOST_RECENT;
    switch (strategy) {
      case ConflictResolutionStrategy.OBSIDIAN_WINS:
        return changes.find((change) => change.source === "obsidian") || changes[0];
      case ConflictResolutionStrategy.SKEDPAL_WINS:
        return changes.find((change) => change.source === "skedpal") || changes[0];
      case ConflictResolutionStrategy.MOST_RECENT:
        return changes.reduce((latest, current) => current.timestamp > latest.timestamp ? current : latest);
      case ConflictResolutionStrategy.MANUAL_RESOLUTION:
        console.warn("Manual conflict resolution not implemented, using most recent change");
        return changes.reduce((latest, current) => current.timestamp > latest.timestamp ? current : latest);
      default:
        return changes[0];
    }
  }
  async applyChanges(changes) {
    for (const change of changes) {
      try {
        if (change.source === "obsidian") {
          await this.applyToSkedPal(change);
        } else {
          await this.applyToObsidian(change);
        }
      } catch (error) {
        console.error(`Failed to apply change for task ${change.taskId}:`, error);
        this.changeQueue.push(change);
      }
    }
    if (this.changeQueue.length > 0 && this.retryCount < this.maxRetries) {
      await this.retryFailedChanges();
    }
  }
  async applyToSkedPal(change) {
    console.log("Applying to SkedPal:", change);
    await new Promise((resolve) => setTimeout(resolve, 100));
  }
  async applyToObsidian(change) {
    console.log("Applying to Obsidian:", change);
    await new Promise((resolve) => setTimeout(resolve, 50));
  }
  async handleSyncError(error) {
    console.error("Synchronization error:", error);
    this.retryCount++;
    if (this.retryCount <= this.maxRetries) {
      console.log(`Retrying synchronization in ${this.retryCount * 5e3}ms`);
      await new Promise((resolve) => setTimeout(resolve, this.retryCount * 5e3));
    } else {
      console.error("Max retry attempts reached");
    }
  }
  async retryFailedChanges() {
    const failedChanges = [...this.changeQueue];
    this.changeQueue = [];
    for (const change of failedChanges) {
      try {
        if (change.source === "obsidian") {
          await this.applyToSkedPal(change);
        } else {
          await this.applyToObsidian(change);
        }
      } catch (error) {
        console.error(`Retry failed for task ${change.taskId}:`, error);
        this.changeQueue.push(change);
      }
    }
  }
  getStatus() {
    return { ...this.syncStatus };
  }
  reset() {
    this.syncStatus = {
      lastSyncTime: new Date(0),
      syncInProgress: false,
      tasksSynced: 0,
      conflictsResolved: 0,
      syncDirection: "bidirectional"
    };
    this.changeQueue = [];
    this.retryCount = 0;
  }
  scheduleAutoSync(intervalMinutes) {
    console.log(`Auto-sync scheduled every ${intervalMinutes} minutes`);
    setInterval(async () => {
      if (!this.syncStatus.syncInProgress) {
        console.log("Auto-sync triggered");
      }
    }, intervalMinutes * 60 * 1e3);
  }
};

// src/main.ts
var Plugin;
var App3;
var TFile2;
var Notice2;
try {
  const obsidian = require("obsidian");
  Plugin = obsidian.Plugin;
  App3 = obsidian.App;
  TFile2 = obsidian.TFile;
  Notice2 = obsidian.Notice;
} catch (error) {
  if (typeof global !== "undefined" && global.obsidian) {
    const obsidian = global.obsidian;
    Plugin = obsidian.Plugin;
    App3 = obsidian.App;
    TFile2 = obsidian.TFile;
    Notice2 = obsidian.Notice;
  } else {
  }
}
var TaskSyncPlugin = class extends Plugin {
  async onload() {
    console.log("Loading Obsidian Tasks - SkedPal Sync plugin");
    await this.loadSettings();
    this.taskManager = new TaskManager(this.app, this.settings);
    this.syncEngine = new SynchronizationEngine(this.settings);
    this.addSettingTab(new TaskSyncSettingTab(this.app, this));
    this.addCommand({
      id: "sync-tasks-to-skedpal",
      name: "Sync tasks to SkedPal",
      callback: () => {
        this.syncTasks();
      }
    });
    this.addCommand({
      id: "sync-tasks-from-skedpal",
      name: "Sync tasks from SkedPal",
      callback: () => {
        this.syncFromSkedPal();
      }
    });
    this.addCommand({
      id: "get-sync-status",
      name: "Get synchronization status",
      callback: () => {
        this.showSyncStatus();
      }
    });
    this.registerEvent(this.app.vault.on("modify", (file) => {
      if (this.isTaskFile(file)) {
        this.handleTaskChange(file);
      }
    }));
    new Notice2("Obsidian Tasks - SkedPal Sync plugin loaded successfully");
  }
  onunload() {
    console.log("Unloading Obsidian Tasks - SkedPal Sync plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  isTaskFile(file) {
    var _a;
    if (file.extension !== "md") {
      return false;
    }
    if (file.path.includes("/tasks/") || file.name.toLowerCase().includes("task")) {
      return true;
    }
    try {
      const cache = (_a = this.app.metadataCache) == null ? void 0 : _a.getFileCache(file);
      if (cache == null ? void 0 : cache.listItems) {
        return cache.listItems.some((item) => item.task !== void 0);
      }
    } catch (error) {
    }
    return false;
  }
  async handleTaskChange(file) {
    if (this.settings.autoSync) {
      await this.syncTasks();
    }
  }
  async syncTasks() {
    try {
      const tasks = await this.taskManager.collectTasks();
      new Notice2(`Found ${tasks.length} tasks to sync`);
      const skedpalTasks = [];
      const syncStatus = await this.syncEngine.synchronizeTasks(tasks, skedpalTasks);
      if (syncStatus.lastError) {
        new Notice2(`Sync completed with errors: ${syncStatus.lastError}`);
      } else {
        new Notice2(`Sync completed: ${syncStatus.tasksSynced} tasks synced, ${syncStatus.conflictsResolved} conflicts resolved`);
      }
    } catch (error) {
      console.error("Error syncing tasks:", error);
      new Notice2("Error syncing tasks: " + error.message);
    }
  }
  async syncFromSkedPal() {
    try {
      const skedpalTasks = [];
      const obsidianTasks = await this.taskManager.collectTasks();
      const syncStatus = await this.syncEngine.synchronizeTasks(obsidianTasks, skedpalTasks);
      if (syncStatus.lastError) {
        new Notice2(`Sync from SkedPal completed with errors: ${syncStatus.lastError}`);
      } else {
        new Notice2(`Sync from SkedPal completed: ${syncStatus.tasksSynced} tasks synced`);
      }
    } catch (error) {
      console.error("Error syncing from SkedPal:", error);
      new Notice2("Error syncing from SkedPal: " + error.message);
    }
  }
  showSyncStatus() {
    const status = this.syncEngine.getStatus();
    const statusMessage = `Synchronization Status:
Last Sync: ${status.lastSyncTime.toLocaleString()}
In Progress: ${status.syncInProgress ? "Yes" : "No"}
Tasks Synced: ${status.tasksSynced}
Conflicts Resolved: ${status.conflictsResolved}
Last Error: ${status.lastError || "None"}`;
    new Notice2(statusMessage);
  }
};
