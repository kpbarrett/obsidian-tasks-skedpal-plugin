/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
var __defProp = Object.defineProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/main.ts
__export(exports, {
  default: () => TaskSyncPlugin
});

// src/task-manager.ts
var App;
var TFile;
var Notice;
var normalizePath;
var MetadataCache;
var CachedMetadata;
try {
  const obsidian = require("obsidian");
  App = obsidian.App;
  TFile = obsidian.TFile;
  Notice = obsidian.Notice;
  normalizePath = obsidian.normalizePath;
  MetadataCache = obsidian.MetadataCache;
  CachedMetadata = obsidian.CachedMetadata;
} catch (error) {
  if (typeof global !== "undefined" && global.obsidian) {
    const obsidian = global.obsidian;
    App = obsidian.App;
    TFile = obsidian.TFile;
    Notice = obsidian.Notice;
    normalizePath = obsidian.normalizePath;
    MetadataCache = obsidian.MetadataCache;
    CachedMetadata = obsidian.CachedMetadata;
  } else {
    normalizePath = (path) => path.replace(/\\/g, "/").replace(/\/+/g, "/").replace(/\/$/, "");
  }
}
var TaskManager = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  isTasksPluginAvailable() {
    var _a, _b;
    return !!((_a = this.app.plugins) == null ? void 0 : _a.getPlugin("obsidian-tasks-plugin")) || !!((_b = this.app.plugins) == null ? void 0 : _b.getPlugin("tasks"));
  }
  getTasksFromMetadataCache() {
    const tasks = [];
    if (!this.app.metadataCache) {
      return tasks;
    }
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (!this.shouldProcessFile(file)) {
        continue;
      }
      const cache = this.app.metadataCache.getFileCache(file);
      if (!cache) {
        continue;
      }
      const fileTasks = this.extractTasksFromCache(file, cache);
      tasks.push(...fileTasks);
    }
    return tasks;
  }
  extractTasksFromCache(file, cache) {
    const tasks = [];
    if (!cache.listItems) {
      return tasks;
    }
    for (const listItem of cache.listItems) {
      if (this.isTaskListItem(listItem)) {
        const task = this.parseTaskFromCache(file, listItem);
        if (task) {
          tasks.push(task);
        }
      }
    }
    return tasks;
  }
  isTaskListItem(listItem) {
    return listItem.task !== void 0;
  }
  parseTaskFromCache(file, listItem) {
    var _a;
    const taskContent = listItem.text || "";
    const completed = listItem.task === "x" || listItem.task === "X";
    if (completed && !this.settings.includeCompletedTasks) {
      return null;
    }
    const metadata = this.parseExtendedTaskMetadata(taskContent);
    return {
      id: this.generateTaskId(file.path, listItem.position.start.line),
      description: metadata.cleanDescription,
      completed,
      filePath: file.path,
      lineNumber: listItem.position.start.line + 1,
      priority: metadata.priority,
      dueDate: metadata.dueDate,
      scheduledDate: metadata.scheduledDate,
      startDate: metadata.startDate,
      doneDate: metadata.doneDate,
      recurrence: metadata.recurrence,
      createdDate: metadata.createdDate,
      tags: metadata.tags,
      rawContent: taskContent,
      fileModifiedTime: (_a = file.stat) == null ? void 0 : _a.mtime
    };
  }
  parseExtendedTaskMetadata(content) {
    let cleanDescription = content;
    let priority;
    let dueDate;
    let scheduledDate;
    let startDate;
    let doneDate;
    let recurrence;
    let createdDate;
    const tags = [];
    const priorityMatch = content.match(/\s\((\w)\)\s/);
    if (priorityMatch) {
      priority = priorityMatch[1];
      cleanDescription = cleanDescription.replace(/\s\(\w\)\s/, " ");
    }
    const dueDateMatch = content.match(/📅\s*(\d{4}-\d{2}-\d{2})|due:(\d{4}-\d{2}-\d{2})/);
    if (dueDateMatch) {
      dueDate = dueDateMatch[1] || dueDateMatch[2];
      cleanDescription = cleanDescription.replace(/📅\s*\d{4}-\d{2}-\d{2}/, "").replace(/due:\d{4}-\d{2}-\d{2}/, "");
    }
    const scheduledMatch = content.match(/⏳\s*(\d{4}-\d{2}-\d{2})|scheduled:(\d{4}-\d{2}-\d{2})/);
    if (scheduledMatch) {
      scheduledDate = scheduledMatch[1] || scheduledMatch[2];
      cleanDescription = cleanDescription.replace(/⏳\s*\d{4}-\d{2}-\d{2}/, "").replace(/scheduled:\d{4}-\d{2}-\d{2}/, "");
    }
    const startMatch = content.match(/🛫\s*(\d{4}-\d{2}-\d{2})|start:(\d{4}-\d{2}-\d{2})/);
    if (startMatch) {
      startDate = startMatch[1] || startMatch[2];
      cleanDescription = cleanDescription.replace(/🛫\s*\d{4}-\d{2}-\d{2}/, "").replace(/start:\d{4}-\d{2}-\d{2}/, "");
    }
    const doneMatch = content.match(/✅\s*(\d{4}-\d{2}-\d{2})|done:(\d{4}-\d{2}-\d{2})/);
    if (doneMatch) {
      doneDate = doneMatch[1] || doneMatch[2];
      cleanDescription = cleanDescription.replace(/✅\s*\d{4}-\d{2}-\d{2}/, "").replace(/done:\d{4}-\d{2}-\d{2}/, "");
    }
    const recurMatch = content.match(/🔁\s*(.+?)(?=\s|$)|recur:(.+?)(?=\s|$)/);
    if (recurMatch) {
      recurrence = recurMatch[1] || recurMatch[2];
      cleanDescription = cleanDescription.replace(/🔁\s*.+?(?=\s|$)/, "").replace(/recur:.+?(?=\s|$)/, "");
    }
    const createdMatch = content.match(/➕\s*(\d{4}-\d{2}-\d{2})|created:(\d{4}-\d{2}-\d{2})/);
    if (createdMatch) {
      createdDate = createdMatch[1] || createdMatch[2];
      cleanDescription = cleanDescription.replace(/➕\s*\d{4}-\d{2}-\d{2}/, "").replace(/created:\d{4}-\d{2}-\d{2}/, "");
    }
    const tagRegex = /#([\w-]+)/g;
    let tagMatch;
    while ((tagMatch = tagRegex.exec(content)) !== null) {
      tags.push(tagMatch[1]);
    }
    cleanDescription = cleanDescription.replace(/\s+/g, " ").trim();
    return {
      cleanDescription,
      priority,
      dueDate,
      scheduledDate,
      startDate,
      doneDate,
      recurrence,
      createdDate,
      tags
    };
  }
  async collectTasks() {
    const cacheTasks = this.getTasksFromMetadataCache();
    if (cacheTasks.length > 0) {
      return cacheTasks;
    }
    const tasks = [];
    const markdownFiles = this.app.vault.getMarkdownFiles();
    for (const file of markdownFiles) {
      if (this.shouldProcessFile(file)) {
        const fileTasks = await this.extractTasksFromFile(file);
        tasks.push(...fileTasks);
      }
    }
    return tasks;
  }
  shouldProcessFile(file) {
    const filePath = normalizePath(file.path);
    for (const pattern of this.settings.taskFilePatterns) {
      if (this.matchesPattern(filePath, pattern)) {
        return true;
      }
    }
    return filePath.includes("/tasks/") || file.name.toLowerCase().includes("task");
  }
  matchesPattern(filePath, pattern) {
    if (pattern.includes("**")) {
      const regexPattern = pattern.replace(/\*\*/g, ".*").replace(/\*/g, "[^/]*").replace(/\?/g, "[^/]");
      const regex = new RegExp(`^${regexPattern}$`);
      return regex.test(filePath);
    }
    return filePath.includes(pattern.replace("*", ""));
  }
  async extractTasksFromFile(file) {
    const tasks = [];
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const task = this.parseTaskLine(line, file.path, i + 1);
      if (task) {
        tasks.push(task);
      }
    }
    return tasks;
  }
  parseTaskLine(line, filePath, lineNumber) {
    const taskRegex = /^\s*[-*]\s*\[(.)\]\s*(.+)$/;
    const match = line.match(taskRegex);
    if (!match) {
      return null;
    }
    const statusChar = match[1].toLowerCase();
    const description = match[2].trim();
    const completed = statusChar === "x";
    if (completed && !this.settings.includeCompletedTasks) {
      return null;
    }
    const metadata = this.parseExtendedTaskMetadata(description);
    return {
      id: this.generateTaskId(filePath, lineNumber),
      description: metadata.cleanDescription,
      completed,
      filePath,
      lineNumber,
      priority: metadata.priority,
      dueDate: metadata.dueDate,
      scheduledDate: metadata.scheduledDate,
      startDate: metadata.startDate,
      doneDate: metadata.doneDate,
      recurrence: metadata.recurrence,
      createdDate: metadata.createdDate,
      tags: metadata.tags,
      rawContent: line
    };
  }
  generateTaskId(filePath, lineNumber) {
    return `${filePath}:${lineNumber}`;
  }
  async updateTask(task, updates) {
    try {
      const file = this.app.vault.getAbstractFileByPath(task.filePath);
      if (!(file instanceof TFile)) {
        throw new Error(`File not found: ${task.filePath}`);
      }
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      if (task.lineNumber > lines.length) {
        throw new Error(`Line ${task.lineNumber} not found in file ${task.filePath}`);
      }
      const updatedLine = this.updateTaskLine(lines[task.lineNumber - 1], updates);
      lines[task.lineNumber - 1] = updatedLine;
      await this.app.vault.modify(file, lines.join("\n"));
    } catch (error) {
      console.error("Error updating task:", error);
      throw error;
    }
  }
  updateTaskLine(originalLine, updates) {
    let updatedLine = originalLine;
    if (updates.completed !== void 0) {
      const statusChar = updates.completed ? "x" : " ";
      updatedLine = updatedLine.replace(/\[(.)\]/, `[${statusChar}]`);
    }
    if (updates.description) {
      const taskMatch = updatedLine.match(/^\s*[-*]\s*\[(.)\]\s*/);
      if (taskMatch) {
        updatedLine = updatedLine.replace(/^\s*[-*]\s*\[(.)\]\s*.*$/, `${taskMatch[0]}${updates.description}`);
      }
    }
    return updatedLine;
  }
  async getModifiedTasks(since) {
    const allTasks = await this.collectTasks();
    return allTasks.filter((task) => {
      if (!task.fileModifiedTime) {
        return true;
      }
      return task.fileModifiedTime > since.getTime();
    });
  }
  async getTasksFromTasksPlugin() {
    const tasks = [];
    if (!this.isTasksPluginAvailable()) {
      return tasks;
    }
    try {
      const tasksPlugin = this.app.plugins.getPlugin("obsidian-tasks-plugin") || this.app.plugins.getPlugin("tasks");
      if (tasksPlugin && tasksPlugin.getTasks) {
        const pluginTasks = tasksPlugin.getTasks();
        for (const pluginTask of pluginTasks) {
          const task = this.convertTasksPluginTask(pluginTask);
          if (task) {
            tasks.push(task);
          }
        }
      }
    } catch (error) {
      console.warn("Error accessing Tasks plugin API:", error);
    }
    return tasks;
  }
  convertTasksPluginTask(pluginTask) {
    if (!pluginTask || !pluginTask.text) {
      return null;
    }
    const metadata = this.parseExtendedTaskMetadata(pluginTask.text);
    return {
      id: pluginTask.id || this.generateTaskId(pluginTask.path || "", pluginTask.line || 0),
      description: metadata.cleanDescription,
      completed: pluginTask.status === "x" || pluginTask.status === "X",
      filePath: pluginTask.path || "",
      lineNumber: pluginTask.line || 0,
      priority: metadata.priority,
      dueDate: metadata.dueDate,
      scheduledDate: metadata.scheduledDate,
      startDate: metadata.startDate,
      doneDate: metadata.doneDate,
      recurrence: metadata.recurrence,
      createdDate: metadata.createdDate,
      tags: metadata.tags,
      rawContent: pluginTask.text,
      status: pluginTask.status,
      blockId: pluginTask.blockId,
      fileModifiedTime: pluginTask.fileModifiedTime
    };
  }
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  autoSync: false,
  skedPalApiKey: "",
  skedPalWorkspaceId: "",
  taskFilePatterns: ["**/*.md"],
  syncInterval: 300,
  includeCompletedTasks: false
};

// src/settings-tab.ts
var App2;
var PluginSettingTab;
var Setting;
var Notice2;
try {
  const obsidian = require("obsidian");
  App2 = obsidian.App;
  PluginSettingTab = obsidian.PluginSettingTab;
  Setting = obsidian.Setting;
  Notice2 = obsidian.Notice;
} catch (error) {
  if (typeof global !== "undefined" && global.obsidian) {
    const obsidian = global.obsidian;
    App2 = obsidian.App;
    PluginSettingTab = obsidian.PluginSettingTab;
    Setting = obsidian.Setting;
    Notice2 = obsidian.Notice;
  } else {
  }
}
var TaskSyncSettingTab = class extends PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Task Sync Settings" });
    this.createSetupGuide(containerEl);
    this.createConfigurationSection(containerEl);
    this.createAdvancedSettingsSection(containerEl);
  }
  createSetupGuide(containerEl) {
    const setupSection = containerEl.createDiv("setup-guide");
    setupSection.createEl("h3", { text: "Quick Setup Guide" });
    const steps = setupSection.createDiv("setup-steps");
    const step1 = steps.createDiv("setup-step");
    step1.createEl("h4", { text: "Step 1: Get SkedPal API Credentials" });
    step1.createEl("p", { text: "1. Log in to your SkedPal account" });
    step1.createEl("p", { text: "2. Go to Settings \u2192 API Keys" });
    step1.createEl("p", { text: "3. Generate a new API key" });
    step1.createEl("p", { text: "4. Copy your Workspace ID from the API settings" });
    const step2 = steps.createDiv("setup-step");
    step2.createEl("h4", { text: "Step 2: Configure Plugin" });
    step2.createEl("p", { text: "1. Enter your API key and Workspace ID below" });
    step2.createEl("p", { text: "2. Enable auto-sync if desired" });
    step2.createEl("p", { text: "3. Adjust sync interval as needed" });
    const step3 = steps.createDiv("setup-step");
    step3.createEl("h4", { text: "Step 3: Test Connection" });
    step3.createEl("p", { text: "1. Use the commands below to test sync" });
    step3.createEl("p", { text: "2. Check the console for any errors" });
    step3.createEl("p", { text: "3. Review sync results in SkedPal" });
    const testButton = new Setting(setupSection).setName("Test Connection").setDesc("Test the connection to SkedPal with current settings").addButton((button) => {
      button.setButtonText("Test Now").onClick(async () => {
        await this.testConnection();
      });
    });
  }
  createConfigurationSection(containerEl) {
    const configSection = containerEl.createDiv("configuration-section");
    configSection.createEl("h3", { text: "Configuration" });
    new Setting(configSection).setName("SkedPal API Key").setDesc("Your SkedPal API key for authentication. Get this from SkedPal Settings \u2192 API Keys.").addText((text) => text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.skedPalApiKey).onChange(async (value) => {
      this.plugin.settings.skedPalApiKey = value;
      await this.plugin.saveSettings();
    }));
    new Setting(configSection).setName("SkedPal Workspace ID").setDesc("Your SkedPal workspace ID. Find this in SkedPal Settings \u2192 API Keys.").addText((text) => text.setPlaceholder("Enter workspace ID").setValue(this.plugin.settings.skedPalWorkspaceId).onChange(async (value) => {
      this.plugin.settings.skedPalWorkspaceId = value;
      await this.plugin.saveSettings();
    }));
    new Setting(configSection).setName("Auto-sync on task changes").setDesc("Automatically sync tasks when they are modified in Obsidian").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSync).onChange(async (value) => {
      this.plugin.settings.autoSync = value;
      await this.plugin.saveSettings();
    }));
  }
  createAdvancedSettingsSection(containerEl) {
    const advancedSection = containerEl.createDiv("advanced-settings");
    advancedSection.createEl("h3", { text: "Advanced Settings" });
    new Setting(advancedSection).setName("Sync interval (seconds)").setDesc("Interval for automatic sync in seconds. Set to 0 to disable automatic sync.").addText((text) => text.setPlaceholder("300").setValue(this.plugin.settings.syncInterval.toString()).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue)) {
        this.plugin.settings.syncInterval = numValue;
        await this.plugin.saveSettings();
      }
    }));
    new Setting(advancedSection).setName("Include completed tasks").setDesc("Sync tasks that are marked as completed in Obsidian").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeCompletedTasks).onChange(async (value) => {
      this.plugin.settings.includeCompletedTasks = value;
      await this.plugin.saveSettings();
    }));
  }
  async testConnection() {
    try {
      if (!this.plugin.settings.skedPalApiKey || !this.plugin.settings.skedPalWorkspaceId) {
        throw new Error("Please provide both API Key and Workspace ID");
      }
      const isConnected = await this.testSkedPalConnection();
      if (isConnected) {
        this.showSuccessMessage("Connection successful! Your SkedPal integration is working correctly.");
      } else {
        throw new Error("Failed to connect to SkedPal. Please check your credentials.");
      }
    } catch (error) {
      this.showErrorMessage(`Connection test failed: ${error.message}`);
    }
  }
  async testSkedPalConnection() {
    return this.plugin.settings.skedPalApiKey.length > 0 && this.plugin.settings.skedPalWorkspaceId.length > 0;
  }
  showSuccessMessage(message) {
    if (typeof Notice2 !== "undefined") {
      new Notice2(`\u2705 ${message}`);
    }
    console.log(`\u2705 ${message}`);
  }
  showErrorMessage(message) {
    if (typeof Notice2 !== "undefined") {
      new Notice2(`\u274C ${message}`);
    }
    console.error(`\u274C ${message}`);
  }
};

// src/skedpal-client.ts
var SkedPalClient = class {
  constructor(apiKey, workspaceId) {
    this.baseUrl = "https://api.skedpal.com/v1";
    this.apiKey = apiKey;
    this.workspaceId = workspaceId;
  }
  convertToSkedPalTask(obsidianTask) {
    const skedPalTask = {
      title: obsidianTask.description,
      description: `From Obsidian: ${obsidianTask.filePath}:${obsidianTask.lineNumber}`,
      externalId: obsidianTask.id,
      tags: [...obsidianTask.tags],
      status: obsidianTask.completed ? "COMPLETED" : "TODO"
    };
    if (obsidianTask.priority) {
      switch (obsidianTask.priority.toUpperCase()) {
        case "A":
          skedPalTask.priority = "HIGH";
          break;
        case "B":
          skedPalTask.priority = "MEDIUM";
          break;
        case "C":
        case "D":
          skedPalTask.priority = "LOW";
          break;
      }
    }
    if (obsidianTask.dueDate) {
      skedPalTask.dueDate = this.formatDateForSkedPal(obsidianTask.dueDate);
    }
    if (obsidianTask.description.length > 100) {
      skedPalTask.estimatedDuration = 30;
    } else {
      skedPalTask.estimatedDuration = 15;
    }
    return skedPalTask;
  }
  formatDateForSkedPal(dateStr) {
    if (dateStr.match(/\d{4}-\d{2}-\d{2}/)) {
      return `${dateStr}T00:00:00Z`;
    }
    const date = new Date(dateStr);
    if (!isNaN(date.getTime())) {
      return date.toISOString();
    }
    return dateStr;
  }
  async makeApiRequest(endpoint, options = {}) {
    const url = `${this.baseUrl}${endpoint}`;
    const defaultOptions = {
      headers: {
        "Authorization": `Bearer ${this.apiKey}`,
        "Content-Type": "application/json",
        "X-Workspace-Id": this.workspaceId
      }
    };
    const finalOptions = {
      ...defaultOptions,
      ...options,
      headers: {
        ...defaultOptions.headers,
        ...options.headers
      }
    };
    try {
      const response = await fetch(url, finalOptions);
      if (!response.ok) {
        throw new Error(`SkedPal API error: ${response.status} ${response.statusText}`);
      }
      return await response.json();
    } catch (error) {
      console.error("SkedPal API request failed:", error);
      throw error;
    }
  }
  async syncTasksToSkedPal(obsidianTasks) {
    const result = {
      success: true,
      syncedTasks: 0,
      errors: [],
      warnings: []
    };
    if (!this.apiKey || !this.workspaceId) {
      result.success = false;
      result.errors.push("SkedPal API credentials not configured");
      return result;
    }
    for (const obsidianTask of obsidianTasks) {
      try {
        const skedPalTask = this.convertToSkedPalTask(obsidianTask);
        const existingTask = await this.findTaskByExternalId(obsidianTask.id);
        if (existingTask) {
          await this.updateTask(existingTask.id, skedPalTask);
        } else {
          await this.createTask(skedPalTask);
        }
        result.syncedTasks++;
      } catch (error) {
        const errorMsg = `Failed to sync task "${obsidianTask.description}": ${error.message}`;
        console.error(errorMsg);
        result.errors.push(errorMsg);
        result.success = false;
      }
    }
    return result;
  }
  async createTask(task) {
    return await this.makeApiRequest("/tasks", {
      method: "POST",
      body: JSON.stringify(task)
    });
  }
  async updateTask(taskId, updates) {
    return await this.makeApiRequest(`/tasks/${taskId}`, {
      method: "PUT",
      body: JSON.stringify(updates)
    });
  }
  async findTaskByExternalId(externalId) {
    try {
      const tasks = await this.makeApiRequest(`/tasks?externalId=${encodeURIComponent(externalId)}`);
      return tasks.length > 0 ? tasks[0] : null;
    } catch (error) {
      console.warn("Error finding task by external ID:", error);
      return null;
    }
  }
  async getTasks() {
    try {
      return await this.makeApiRequest("/tasks");
    } catch (error) {
      console.error("Error getting tasks from SkedPal:", error);
      throw error;
    }
  }
  async getModifiedTasks(since) {
    try {
      const sinceStr = since.toISOString();
      return await this.makeApiRequest(`/tasks?updatedSince=${encodeURIComponent(sinceStr)}`);
    } catch (error) {
      console.error("Error getting modified tasks from SkedPal:", error);
      throw error;
    }
  }
  async deleteTask(taskId) {
    try {
      await this.makeApiRequest(`/tasks/${taskId}`, {
        method: "DELETE"
      });
    } catch (error) {
      console.error("Error deleting task from SkedPal:", error);
      throw error;
    }
  }
  async testConnection() {
    try {
      await this.makeApiRequest("/workspaces");
      return true;
    } catch (error) {
      console.error("SkedPal connection test failed:", error);
      return false;
    }
  }
  convertToObsidianTask(skedPalTask) {
    const obsidianTask = {
      description: skedPalTask.title,
      completed: skedPalTask.status === "COMPLETED",
      tags: skedPalTask.tags || []
    };
    if (skedPalTask.priority) {
      switch (skedPalTask.priority) {
        case "HIGH":
          obsidianTask.priority = "A";
          break;
        case "MEDIUM":
          obsidianTask.priority = "B";
          break;
        case "LOW":
          obsidianTask.priority = "C";
          break;
      }
    }
    if (skedPalTask.dueDate) {
      const date = new Date(skedPalTask.dueDate);
      obsidianTask.dueDate = date.toISOString().split("T")[0];
    }
    return obsidianTask;
  }
};

// src/main.ts
var Plugin;
var App3;
var TFile2;
var Notice3;
try {
  const obsidian = require("obsidian");
  Plugin = obsidian.Plugin;
  App3 = obsidian.App;
  TFile2 = obsidian.TFile;
  Notice3 = obsidian.Notice;
} catch (error) {
  if (typeof global !== "undefined" && global.obsidian) {
    const obsidian = global.obsidian;
    Plugin = obsidian.Plugin;
    App3 = obsidian.App;
    TFile2 = obsidian.TFile;
    Notice3 = obsidian.Notice;
  } else {
  }
}
var TaskSyncPlugin = class extends Plugin {
  async onload() {
    console.log("Loading Obsidian Tasks - SkedPal Sync plugin");
    await this.loadSettings();
    this.taskManager = new TaskManager(this.app, this.settings);
    this.skedPalClient = new SkedPalClient(this.settings.skedPalApiKey, this.settings.skedPalWorkspaceId);
    this.addSettingTab(new TaskSyncSettingTab(this.app, this));
    this.addCommand({
      id: "sync-tasks-to-skedpal",
      name: "Sync tasks to SkedPal",
      callback: () => {
        this.syncTasks();
      }
    });
    this.addCommand({
      id: "sync-tasks-from-skedpal",
      name: "Sync tasks from SkedPal",
      callback: () => {
        this.syncFromSkedPal();
      }
    });
    this.addCommand({
      id: "test-skedpal-connection",
      name: "Test SkedPal connection",
      callback: () => {
        this.testConnection();
      }
    });
    this.registerEvent(this.app.vault.on("modify", (file) => {
      if (this.isTaskFile(file)) {
        this.handleTaskChange(file);
      }
    }));
    this.showSetupGuidance();
    new Notice3("Obsidian Tasks - SkedPal Sync plugin loaded successfully");
  }
  onunload() {
    console.log("Unloading Obsidian Tasks - SkedPal Sync plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  isTaskFile(file) {
    var _a;
    if (file.extension !== "md") {
      return false;
    }
    if (file.path.includes("/tasks/") || file.name.toLowerCase().includes("task")) {
      return true;
    }
    try {
      const cache = (_a = this.app.metadataCache) == null ? void 0 : _a.getFileCache(file);
      if (cache == null ? void 0 : cache.listItems) {
        return cache.listItems.some((item) => item.task !== void 0);
      }
    } catch (error) {
    }
    return false;
  }
  async handleTaskChange(file) {
    if (this.settings.autoSync) {
      await this.syncTasks();
    }
  }
  async syncTasks() {
    try {
      if (!this.isConfigured()) {
        this.showSetupRequiredMessage();
        return;
      }
      const connectionOk = await this.skedPalClient.testConnection();
      if (!connectionOk) {
        new Notice3("Failed to connect to SkedPal. Please check your API credentials.");
        return;
      }
      const tasks = await this.taskManager.collectTasks();
      new Notice3(`Found ${tasks.length} tasks to sync to SkedPal...`);
      const result = await this.skedPalClient.syncTasksToSkedPal(tasks);
      if (result.success) {
        new Notice3(`Successfully synced ${result.syncedTasks} tasks to SkedPal`);
        if (result.warnings.length > 0) {
          console.warn("SkedPal sync warnings:", result.warnings);
        }
      } else {
        new Notice3(`Failed to sync tasks to SkedPal. ${result.errors.length} errors occurred.`);
        console.error("SkedPal sync errors:", result.errors);
      }
    } catch (error) {
      console.error("Error syncing tasks to SkedPal:", error);
      new Notice3("Error syncing tasks to SkedPal: " + error.message);
    }
  }
  async syncFromSkedPal() {
    try {
      if (!this.isConfigured()) {
        this.showSetupRequiredMessage();
        return;
      }
      const connectionOk = await this.skedPalClient.testConnection();
      if (!connectionOk) {
        new Notice3("Failed to connect to SkedPal. Please check your API credentials.");
        return;
      }
      new Notice3("Syncing tasks from SkedPal...");
      const skedPalTasks = await this.skedPalClient.getTasks();
      new Notice3(`Found ${skedPalTasks.length} tasks in SkedPal`);
      if (skedPalTasks.length > 0) {
        new Notice3(`Found ${skedPalTasks.length} tasks in SkedPal. Import functionality coming soon.`);
      } else {
        new Notice3("No tasks found in SkedPal");
      }
    } catch (error) {
      console.error("Error syncing from SkedPal:", error);
      new Notice3("Error syncing from SkedPal: " + error.message);
    }
  }
  async testConnection() {
    try {
      if (!this.isConfigured()) {
        this.showSetupRequiredMessage();
        return;
      }
      new Notice3("Testing SkedPal connection...");
      const connectionOk = await this.skedPalClient.testConnection();
      if (connectionOk) {
        new Notice3("\u2705 SkedPal connection test successful!");
      } else {
        new Notice3("\u274C Failed to connect to SkedPal. Please check your credentials.");
      }
    } catch (error) {
      console.error("Error testing connection:", error);
      new Notice3("Error testing connection: " + error.message);
    }
  }
  isConfigured() {
    return this.settings.skedPalApiKey.length > 0 && this.settings.skedPalWorkspaceId.length > 0;
  }
  showSetupRequiredMessage() {
    new Notice3("\u26A0\uFE0F Please configure SkedPal API credentials in plugin settings first");
  }
  showSetupGuidance() {
    if (!this.isConfigured()) {
      const hasShownGuidance = this.app.loadLocalStorage("task-sync-setup-guidance");
      if (!hasShownGuidance) {
        new Notice3("\u{1F527} Obsidian Tasks - SkedPal Sync plugin loaded. Please configure your SkedPal API credentials in settings.");
        this.app.saveLocalStorage("task-sync-setup-guidance", "true");
      }
    }
  }
};
